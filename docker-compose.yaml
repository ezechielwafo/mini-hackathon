version: '3.8'

services:

  database:
    image: postgres:13-alpine
    container_name: taskmaster_db
    # Le port 5432 n'a pas besoin d'être exposé sur l'hôte si seul le backend y accède
    # ports:
    #   - "5432:5432"
    environment:
      POSTGRES_DB: ${DB_NAME:-taskmaster_db}
      POSTGRES_USER: ${DB_USER:-taskmaster_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-taskmaster_password}
    volumes:
      - db_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-taskmaster_user} -d ${DB_NAME:-taskmaster_db}"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - backend # Connecte la base de données au réseau backend

  backend:
    build:
      context: ./server # Spécifie le répertoire de construction
      dockerfile: Dockerfile # Spécifie le nom du Dockerfile
    container_name: taskmaster_backend
    env_file: .env # Lit les variables d'environnement depuis le fichier .env racine
    command: > # Exécute les migrations puis lance Gunicorn
      sh -c "
        # Attendre que la base de données soit prête (optionnel, depends_on aide déjà)
        # while ! nc -z database 5432; do
        #   echo 'Waiting for database...'
        #   sleep 1
        # done
        # echo 'Database started'

        # Appliquer les migrations (ajoutez --noinput pour l'automatisation)
        python run manage.py migrate --noinput &&

        # Collecter les fichiers statiques (utile pour la production avec Nginx)
        python run manage.py collectstatic --noinput &&

        # Lancer le serveur d'application Gunicorn
        gunicorn run server_config.wsgi:application --bind 0.0.0.0:8000
      "
    # Le port 8000 n'a pas besoin d'être exposé sur l'hôte si seul Nginx y accède
    ports:
      - "8000:8000"
    expose: # Expose le port 8000 à d'autres services sur le réseau Docker
      - "8000"
    volumes:
      - ./server:/app # Mappe le code source pour le développement
      # Mappe le répertoire staticfiles pour que Nginx puisse y accéder (si Nginx sert les statiques)
      - static_volume:/app/staticfiles

    networks:
      - backend # Connecte le backend au réseau backend

    depends_on:
      database:
        condition: service_healthy # Démarre le backend seulement si la base de données est saine

  frontend:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: taskmaster_frontend
    command: npm run dev -- --host 0.0.0.0
    volumes:
      - ./client:/app
      - /app/node_modules
    # Le port 5173 n'a pas besoin d'être exposé sur l'hôte si seul Nginx y accède
    # ports:
    #   - "5173:5173"
    expose: # Expose le port 5173 à d'autres services sur le réseau Docker
      - "5173"
    environment:
      # Le frontend accède au backend via Nginx, donc l'URL de l'API sera l'URL de Nginx
      # En développement, Nginx redirige vers le backend interne
      # VITE_API_URL: http://backend:8000/api/ # Cette URL est pour la communication directe backend-frontend dans le réseau Docker
      # Si le frontend accède via Nginx, l'URL sera relative ou l'URL de Nginx
      VITE_API_URL: http://nginx/api/ # Le frontend accède à l'API via Nginx
    networks:
      - frontend # Connecte le frontend à son propre réseau (ou au réseau par défaut si pas de réseau frontend dédié)
      - backend # Connecte le frontend au réseau backend pour qu'il puisse potentiellement accéder directement au backend (moins courant avec Nginx)
    depends_on:
      - backend # Démarre le frontend après le backend

  nginx:
    build:
      context: ./proxy
      dockerfile: Dockerfile
    container_name: taskmaster_nginx
    ports:
      - "80:80" # Mappe le port 80 de l'hôte au port 80 du conteneur
    volumes:
      - ./proxy/nginx.conf:/etc/nginx/nginx.conf:ro # Mappe le fichier de configuration Nginx
      # Mappe le répertoire staticfiles du backend pour que Nginx puisse servir les statiques
      - static_volume:/app/staticfiles:ro
    networks:
      - frontend # Connecte Nginx au réseau frontend pour rediriger le trafic vers le frontend
      - backend # Connecte Nginx au réseau backend pour rediriger le trafic vers le backend
    depends_on:
      - frontend # Démarre Nginx après le frontend
      - backend # Démarre Nginx après le backend

networks:
  backend: # Définit le réseau backend
    driver: bridge
  frontend: # Définit le réseau frontend (optionnel, peut utiliser le réseau par défaut)
    driver: bridge

volumes:
  db_data: # Volume pour les données de la base de données
  static_volume: # Volume pour les fichiers statiques collectés par le backend
